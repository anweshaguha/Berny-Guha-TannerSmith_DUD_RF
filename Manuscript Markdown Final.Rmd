---
title: "Markdown for Berny et al. 2026"
author: "Lauren Berny & Anwesha Guha"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(rio)
library(janitor)
library(mice)
library(glmnet)
library(recipes)
library(cutpointr)
library(vip)
library(caret)
library(gtools)
library(finalfit)
library(DALEX)
library(patchwork)
library(iBreakDown)
library(r2d3)
library(gtsummary)
library(effsize)
library(epitools)
library(tidyverse)
library(ggforce)
library(renv)
library(ranger)
```

This code was used for the secondary data analyses reported in “Distinguishing a Drug Use Disorder from Drug Use in a High-Risk Sample of Youth: A Random Forest Classification and Explanatory Analysis,” by Lauren Berny, Anwesha Guha, and Emily Tanner-Smith (*Drug and Alcohol Dependence Reports*). Please cite the published article when using or referencing this code: https://doi.org/10.1016/j.dadr.2026.100412.

# Packages Loaded

```{r}
snapshot()
```

# Important Notes

**Please download the parent study data directly from ICPSR's Repository**: https://www.icpsr.umich.edu/web/NAHDAP/studies/36769


All final objects in **Workspace_DADR - Berny et al.RData** correspond to the results and figures reported in our DADR publication. Re-running this code without loading the workspace may yield slightly different results due to variations in background processing and computational settings.

# Data & Workspace

```{r}
DS1 <- import(here("36769-0001-Data.dta")) #baseline dataset (see ICPSR)

DS2 <- import(here("36769-0002-Data.dta")) #youth dataset (see ICPSR)

DS3 <- import(here("36769-0003-Data.dta")) #young adult dataset (see ICPSR)

load("Workspace_DADR - Berny et al.RData")
```

# Data Pre-Processing

## Recode Missing and Clean Names

```{r}
ds1 <- DS1 %>%
 mutate_all(~ ifelse(. %in% c(-9, 8888, 9999), NA, .)) %>% 
 clean_names()

ds2 <- DS2 %>%
 mutate_all(~ ifelse(. %in% c(-9, 8888, 9999), NA, .)) %>% 
 clean_names()

ds3 <- DS3 %>%
 mutate_all(~ ifelse(. %in% c(-9, 8888, 9999), NA, .)) %>% 
 clean_names()
```

## Make Factors

```{r}
ds1$demoage <- factor(ds1$demoage, levels = c(1, 2, 3), 
                      labels = c("Age 14 to 17", "Age 18 to 20", "Age 21 to 24"))

ds1$demorac <- factor(ds1$demorac, levels = c(4, 5, 6, 7),
                      labels = c("AA or Black", "White", "Multiple Races", 
                                 "American Indian/Asian/Native Hawaiian"))

ds1$demosex <- factor(ds1$demosex, levels = c(1, 2),
                      labels = c("Male", "Female"))

ds1$livewith <- factor(ds1$livewith, levels = c(0, 1), labels = c("No", "Yes"))

ds1$school <- factor(ds1$school, levels = c(0, 1), labels = c("No", "Yes"))

ds1$gang1 <- factor(ds1$gang1, levels = c(0, 1), labels = c("No", "Yes"))

ds1 <- mutate(ds1, weapon1 = ifelse(weapon1 > 0, 1, 0))

ds1 <- mutate(ds1, weapon2a = ifelse(weapon2a > 0, 1, 0))

ds1$weapon1 <- factor(ds1$weapon1, levels = c(0, 1), labels = c("No", "Yes"))

ds1$weapon2a <- factor(ds1$weapon2a, levels = c(0, 1), labels = c("No", "Yes"))

ds1$earlyinit_mj <- with(ds1, ifelse(agepot >= 1 & agepot <= 7, "Yes",
                        ifelse(agepot == 0 | agepot >= 8, "No", NA)))

ds1$earlyinit_mj <- factor(ds1$earlyinit_mj, levels = c("No", "Yes"))

ds1$earlyinit_alc <- with(ds1, ifelse(agedrk >= 1 & agedrk <= 7, "Yes",
                        ifelse(agedrk == 0 | agedrk >= 8, "No", NA)))

ds1$earlyinit_alc <- factor(ds1$earlyinit_alc, levels = c("No", "Yes"))

# Create a function to recode the variables
recode_age <- function(x) {
  ifelse(x >= 1 & x <= 7, "Yes",
         ifelse(x == 0 | x >= 8, "No", NA))
}

# Apply the recoding function to each variable and store the result in a new column
ds1$earlyinit_oth <- with(ds1, 
  ifelse(recode_age(agecoc) == "Yes" |
         recode_age(agemeth) == "Yes" |
         recode_age(ageinhal) == "Yes" |
         recode_age(agehal) == "Yes" |
         recode_age(ageop) == "Yes" |
         recode_age(ageprstim) == "Yes" |
         recode_age(ageprsed) == "Yes" |
         recode_age(ageprop) == "Yes", "Yes", "No"))

# Columns to include in the calculation
age_columns <- c("agepot", "agecoc", "agemeth", "ageinhal", "agehal", "ageop", "ageprstim", 
                 "ageprsed", "ageprop", "agedrk")

# Function to find the minimum value greater than zero or return NA if only zeros or NAs
min_nonzero <- function(row) {
  non_zero_values <- row[row > 0 & !is.na(row)]
  if (length(non_zero_values) == 0) {
    return(NA)
  } else {
    return(min(non_zero_values, na.rm = TRUE))
  }
}

# Apply the function to the relevant columns
ds1$agedruginit <- apply(ds1[age_columns], 1, min_nonzero)

ds1$agedruginit <- ds1$agedruginit + 7 #to make years rather than Likert

ds1$sexint <- factor(ds1$sex, levels = c(0, 1), labels = c("No", "Yes"))

ds1$binge <- factor(ds1$binge, levels = c(0, 1), labels = c("No", "Yes"))

ds1$publicass <- factor(ds1$publicass, levels = c(0, 1), labels = c("No", "Yes"))

ds1$partnervic <- factor(ds1$partnervic, levels = c(0, 1), labels = c("No", "Yes"))

ds1$pcts <- factor(ds1$pcts, levels = c(0, 1), labels = c("No", "Yes"))

ds2$vgroup <- factor(ds2$vgroup, levels = c(0, 1), 
                     labels = c("Comparison Group", "Assaulted Group"))

ds2$alcdx <- factor(ds2$alcdx, levels = c(0, 1), labels = c("No", "Yes"))

ds2$drugdx <- factor(ds2$drugdx, levels = c(0, 1), labels = c("No", "Yes"))

ds2$ptsd <- factor(ds2$ptsd, levels = c(0, 1), labels = c("No", "Yes"))

ds2$cdapd <- factor(ds2$conductdisorder, levels = c(0, 1), labels = c("No", "Yes"))

ds2$legalsev <- ds2$asiteen11

ds2 <- mutate(ds2, personalcrime = ifelse(asiteen2_c1g1 > 0, 1, 0))

ds2 <- mutate(ds2, propertycrime = ifelse(asiteen2_c1g2 > 0, 1, 0))

ds2 <- mutate(ds2, drugcrime = ifelse(asiteen2_c1g3 > 0, 1, 0))

ds2 <- mutate(ds2, publicorder = ifelse(asiteen2_c1g4 > 0, 1, 0))

ds2 <- mutate(ds2, parprobcc = ifelse(asiteen2_c1g5 > 0, 1, 0))

ds2$sexdrug <- factor(ds2$sexdrug, levels = c(0, 1), labels = c("No", "Yes"))

ds2$mentman <- factor(ds2$mentman, levels = c(0, 1), labels = c("No", "Yes"))

ds2$mentwoman <- factor(ds2$mentwoman, levels = c(0, 1), labels = c("No", "Yes"))

ds3$vgroup <- factor(ds3$vgroup, levels = c(0, 1), 
                     labels = c("Comparison Group", "Assaulted Group"))

ds3$alcdx <- factor(ds3$alcdx, levels = c(0, 1), labels = c("No", "Yes"))

ds3$drugdx <- factor(ds3$drugdx, levels = c(0, 1), labels = c("No", "Yes"))

ds3$ptsd <- factor(ds3$ptsd, levels = c(0, 1), labels = c("No", "Yes"))

ds3$cdapd <- factor(ds3$apd, levels = c(0, 1), labels = c("No", "Yes"))

ds3$legalsev <- ds3$asi12

ds3$sexdrug <- factor(ds3$sexdrug, levels = c(0, 1), labels = c("No", "Yes"))

ds3$mentman <- factor(ds3$mentman, levels = c(0, 1), labels = c("No", "Yes"))

ds3$mentwoman <- factor(ds3$mentwoman, levels = c(0, 1), labels = c("No", "Yes"))

ds3 <- mutate(ds3, personalcrime = ifelse(asi2_c1g1 > 0, 1, 0))

ds3 <- mutate(ds3, propertycrime = ifelse(asi2_c1g2 > 0, 1, 0))

ds3 <- mutate(ds3, drugcrime = ifelse(asi2_c1g3 > 0, 1, 0))

ds3 <- mutate(ds3, publicorder = ifelse(asi2_c1g4 > 0, 1, 0))

ds3 <- mutate(ds3, parprobcc = ifelse(asi2_c1g5 > 0, 1, 0))
```

## Composite Scores

Reverse coding noted when applicable.

```{r}
ds1$grades_rev <- 10 - ds1$grades #reverse

ds1$reatt_rev <- 35 - ds1$reatt #reverse

ds1$fight <- rowMeans(ds1[, c("fight1", "fight2", "fight3", "fight4")], na.rm = TRUE)

ds2$dui <- rowMeans(ds2[, c("dui1", "dui2", "dui3", "dui4", "dui5")], na.rm = TRUE)

ds2$infrndps <- rowMeans(ds2[, c("infrndps1", "infrndps2", "infrndps3", "infrndps4")], 
                         na.rm = TRUE)

ds2$infrndng <- rowMeans(ds2[, c("infrndng1", "infrndng5", "infrndng6", "infrndng10",
                                 "infrndng12", "infrndng13", "infrndng15")], 
                         na.rm = TRUE)

ds2$parntsup <- rowMeans(ds2[, c("parntsup1", "parntsup2", "parntsup3", "parntsup4",
                                 "parntsup5", "parntsup6")], 
                         na.rm = TRUE)

ds2$prntdral <- rowMeans(ds2[, c("prntdral3", "prntdral4", "prntdral6", "prntdral10")], 
                         na.rm = TRUE)

ds2$famanger <- rowMeans(ds2[, c("famanger1", "famanger2", "famanger3", "famanger4")], 
                         na.rm = TRUE)

ds2$nofight <- rowMeans(ds2[, c("nofight_r1", "nofight_r2", "nofight_r3", "nofight_r4",
                                "nofight_r5")], 
                        na.rm = TRUE)

ds2$commviol <- rowMeans(ds2[, c("commviol1", "commviol3", "commviol5", "commviol10")], 
                         na.rm = TRUE)

ds3$dui <- rowMeans(ds3[, c("dui1", "dui2", "dui3", "dui4", "dui5")], na.rm = TRUE)

ds3$infrndps <- rowMeans(ds3[, c("infrndps1", "infrndps2", "infrndps3", "infrndps4")], 
                         na.rm = TRUE)

ds3$infrndng <- rowMeans(ds3[, c("infrndng1", "infrndng5", "infrndng6", "infrndng10",
                                 "infrndng12", "infrndng13", "infrndng15")], 
                         na.rm = TRUE)

ds3$parntsup <- rowMeans(ds3[, c("parntsup1", "parntsup2", "parntsup3", "parntsup4",
                                 "parntsup5", "parntsup6")], 
                         na.rm = TRUE)

ds3$prntdral <- rowMeans(ds3[, c("prntdral3", "prntdral4", "prntdral6", "prntdral10")], 
                         na.rm = TRUE)

ds3$famanger <- rowMeans(ds3[, c("famanger1", "famanger2", "famanger3", "famanger4")], 
                         na.rm = TRUE)

ds3$nofight <- rowMeans(ds3[, c("nofight_r1", "nofight_r2", "nofight_r3", "nofight_r4",
                                "nofight_r5")], 
                         na.rm = TRUE)

ds3$commviol <- rowMeans(ds3[, c("commviol1", "commviol3", "commviol5", "commviol10")], 
                         na.rm = TRUE)

ds3$commviol <- rowMeans(ds3[, c("commviol1", "commviol3", "commviol5", "commviol10")], 
                         na.rm = TRUE)

ds3$sedare <- 6 - rowMeans(ds3[, c("sedare1", "sedare2", "sedare3", "sedare4", "sedare5",
                               "sedare6", "sedare7", "sedare8")], na.rm = TRUE) #reverse

ds3$sedarea <- 6 - rowMeans(ds3[, c("sedarea1", "sedarea2", "sedarea3", "sedarea4", "sedarea5",
                               "sedarea6", "sedarea7", "sedarea8")], na.rm = TRUE) #reverse

ds2$crime <- rowSums(ds2[, c("personalcrime", "propertycrime", "drugcrime", "publicorder", 
                         "parprobcc")], na.rm = TRUE)

ds3$crime <- rowSums(ds3[, c("personalcrime", "propertycrime", "drugcrime", "publicorder", 
                         "parprobcc")], na.rm = TRUE)
```

## Select, Append, and Merge

Note: We only included these variables in the random forest models.

```{r}
ds1 <- ds1 %>% 
 select(deid, demoage, demosex, demorac, livewith, school, gang1, weapon1, weapon2a,
        sexint, publicass, partnervic, pcts, fight, grades_rev, reatt_rev, pviclevel, 
        pagglevel, binge, agedruginit)

ds2 <- ds2 %>% 
 select(deid, vgroup, alcdx, drugdx, ptsd, cdapd, legalsev, sexdrug, mentman, mentwoman,
        dui, infrndps, infrndng, parntsup, prntdral, famanger, nofight, commviol,
        bsi, anx, nprcts1to13, npects1to13, crime, sedare1, sedare2, sedare3, sedare4, sedare5,
        sedare6, sedare7, sedare8) 

ds3 <- ds3 %>% 
 select(deid, vgroup, alcdx, drugdx, ptsd, cdapd, legalsev, sexdrug, mentman, mentwoman,
        dui, infrndps, infrndng, parntsup, prntdral, famanger, nofight, commviol,
        bsi, anx, nprcts1to13, npects1to13, crime, sedare1, sedare2, sedare3, sedare4, sedare5,
        sedare6, sedare7, sedare8)

ds23 <- smartbind(ds2, ds3)

rownames(ds23) <- NULL

dat <- merge(ds1, ds23, by = "deid")

dat$legalsev <- as.integer(dat$legalsev)
dat$agedruginit <- as.integer(dat$agedruginit)
dat$sedare1 <- as.integer(dat$sedare1)
dat$sedare2 <- as.integer(dat$sedare2)
dat$sedare3 <- as.integer(dat$sedare3)
dat$sedare4 <- as.integer(dat$sedare4)
dat$sedare5 <- as.integer(dat$sedare5)
dat$sedare6 <- as.integer(dat$sedare6)
dat$sedare7 <- as.integer(dat$sedare7)
dat$sedare8 <- as.integer(dat$sedare8)
dat$npects1to13 <- as.integer(dat$npects1to13)
dat$nprcts1to13 <- as.integer(dat$nprcts1to13)
dat$crime <- as.integer(dat$crime)
dat$anx <- as.integer(dat$anx)
dat$bsi <- as.integer(dat$bsi)
dat$pviclevel <- as.integer(dat$pviclevel)
dat$pagglevel <- as.integer(dat$pagglevel)
dat$reatt_rev <- as.integer(dat$reatt_rev)
dat$grades_rev <- as.integer(dat$grades_rev)

#str(dat)
```

# Variable Labels (See Supplemental Material 1)
Drug use disorder = drugdx   
Age = demoage   
Race = demorac   
Biological sex = demosex   
Public assistance = publicass   
School enrollment = school   
Academic performance = grades_rev   
Condition = vgroup   
Household = livewith   
Parent support = parntsup   
Parent substance use = prntdral   
Family anger = famanger   
Male mentor = mentman   
Female mentor = mentwoman   
Positive peer influence = infrndps   
Negative peer influence = infrndng   
Gang affiliation = gang1   
Sexual intercourse = sexint   
Fighting behavior = fight   
Retaliation attitudes = reatt_rev   
Ability to avoid fighting = nofight   
Community violence = commviol   
Knife/razor carrying = weapon1   
Firearm carrying = weapon2a   
Intimate partner violence = pcts   
IPV victim = partnervic   
IPV victim severity = pviclevel   
IPV perpetrator severity = pagglevel   
Non-partner violence victimization count = nprcts1to13   
Non-partner violence perpetration count = npects1to13   
Intoxicated driving = dui   
Legal problem severity = legalsev
Crime = crime   
Depression symptoms = bsi   
Anxiety symptoms = anx   
Posttraumatic stress disorder = ptsd   
Conduct disorder or antisocial personality disorder = cdapd   
Alcohol use disorder = alcdx   
Binge drinking = binge   
Intoxicated sex = drugsex   
Drug initiation age = agedruginit   
Tempted - let myself down = sedare1   
Tempted - people didn’t like me = sedare2   
Tempted - friend problems = sedare3   
Tempted - family problems = sedare4   
Tempted - made fun of for abstaining = sedare5   
Tempted - friends would like me more = sedare6   
Tempted - all friends were doing it = sedare7   
Tempted - worried about a problem = sedare8   

# Recipe

## Examine Missingness

```{r}
dat %>%
  missing_plot()

dat %>% 
 missing_glimpse() %>% 
 arrange(desc(missing_n))

missing_columns <- colnames(dat)[apply(dat, 2, function(x) any(is.na(x)))]
```

# Make Recipe

See **Supplemental Material 2** for data pre-processing information.

```{r}
dat <- dat %>% 
 relocate(drugdx)

factor_cols_more_than_2_levels <- names(Filter(function(x) is.factor(x) && length(levels(x)) > 2, dat))

blueprint <- recipe(x = dat, vars  = colnames(dat),
                    roles = c('outcome', 'id', rep('predictor', 48))) %>%
 step_impute_bag(all_of(missing_columns), seed_val = sample.int(10312022)) %>%
 step_dummy(all_of(factor_cols_more_than_2_levels),one_hot=TRUE)

# blueprint
```

# Cross-Validation and Accuracy Function

See **Supplemental Material 2** for cross-validation information.

```{r}
set.seed(10312022)

# Shuffle the indices
shuffle_indices <- sample(nrow(dat))

# Create 10 folds with equal size
folds <- cut(seq(1, nrow(dat)), breaks = 10, labels = FALSE)

# Create the list for each fold 
my.indices <- vector('list', 10)
for (i in 1:10) {
  my.indices[[i]] <- shuffle_indices[which(folds != i)]
}

# Define custom summary function for accuracy
accuracySummary <- function(data, lev = NULL, model = NULL) {
  acc <- sum(data$obs == data$pred) / length(data$obs)
  out <- c(Accuracy = acc)
  out
}

cv <- trainControl(method = "cv",
                   index = my.indices,
                   classProbs = TRUE,
                   savePredictions = "final",
                   returnData = TRUE,
                   returnResamp = "final",
                   summaryFunction = accuracySummary)
```


# Random Forest Estimation

See **Supplemental Material 2** for information on how the random forest models were estimated using an iterative hyperparameter tuning process.

## 1: Initial Tuning

```{r init tune}
# Define the grid of values for mtry, num.trees, and min.node.size
mtry_values <- c(13:16)
num_trees <- c(seq(600,900,50))
min_node_size_values <- c(10:21)

num_combinations <- length(mtry_values) * length(num_trees) * length(min_node_size_values)
results_matrix <- matrix(NA, nrow = num_combinations, ncol = 4,
                         dimnames = list(NULL, c("mtry", "num.trees", "min.node.size", "Accuracy")))

set.seed(10312022)

index <- 1

for (i in seq_along(mtry_values)) {
 for (j in seq_along(num_trees)) {
  for (k in seq_along(min_node_size_values)) {
   grid <- expand.grid(
    mtry = mtry_values[i],
    splitrule = 'gini',
    min.node.size = min_node_size_values[k]
   )
   
   rforest <- train(blueprint,
                    data = dat,
                    method = 'ranger',
                    trControl = cv,
                    tuneGrid = grid,
                    num.trees = num_trees[j],
                    replace = TRUE,
                    sample.fraction = 0.8,
                    max.depth = 10,
                    importance = 'impurity'
   )
   
   results_matrix[index, 1] <- mtry_values[i]
   results_matrix[index, 2] <- num_trees[j]
   results_matrix[index, 3] <- min_node_size_values[k]
   results_matrix[index, 4] <- rforest$results$Accuracy
   
   index <- index + 1
  }
 }
}

# Find the row index with the highest accuracy
max_Accuracy_row1 <- which.max(results_matrix[, "Accuracy"])

best_model_values1 <- results_matrix[max_Accuracy_row1, ]
```

## 2:	Depth Refinement

```{r refine1}
# Set seed for reproducibility
set.seed(10312022)

# Define the parameter grid
grid <- expand.grid(
  mtry = 16,
  min.node.size = 11,
  splitrule = 'gini'
)

# Number of depths to iterate over
max_depths <- c(5:15)

# Results matrix to store evaluation metrics
results <- matrix(NA, nrow = length(max_depths), ncol = 7,
                  dimnames = list(NULL, c("Max_Depth", "Accuracy", "AUC", "Precision", 
                                          "TNR", "TPR", "FPR")))

# Loop over different max depths
for (i in seq_along(max_depths)) {
  # Train the model with specified parameters
  rforest <- caret::train(
    blueprint,
    data = dat,
    method = 'ranger',
    tuneGrid = grid,
    trControl = cv,
    num.trees = 600,
    replace = TRUE,
    sample.fraction = 0.8,
    max.depth = max_depths[i],
    importance = 'permutation'
  )

  obs <- rforest$pred$obs
  pred <- rforest$pred$pred

  # Create confusion matrix
  conf_matrix <- confusionMatrix(data = factor(pred), reference = factor(obs), positive = "Yes")

  # Extract the confusion matrix
  cm <- conf_matrix$table

  # Calculate True Positives (TP), True Negatives (TN), False Positives (FP)
  TN <- cm["No",  "No"]
  FN <- cm["No",  "Yes"]
  FP <- cm["Yes", "No"]
  TP <- cm["Yes", "Yes"]

  # Calculate Accuracy
  accuracy <- (TP + TN) / sum(cm)

  # Calculate Precision
  precision <- TP / (TP + FP)

  # Calculate False Positive Rate (FPR)
  FPR <- FP / (FP + TN)

  # Calculate True Negative Rate (TNR)
  TNR <- TN / (TN + FP)

  # Calculate True Positive Rate (TPR)
  TPR <- TP / (TP + FN)

  # Calculate AUC
  cut.obj <- cutpointr::cutpointr(x = rforest$pred$Yes,
                                  class = rforest$pred$obs)
  AUC <- cutpointr::auc(cut.obj)

  # Store results in the results matrix
  results[i, ] <- c(max_depths[i], accuracy, AUC, precision, TNR, TPR, FPR)
}

# View results
print(results)

max_Accuracy_row2 <- which.max(results[, "Accuracy"])

best_model_values2 <- results[max_Accuracy_row2, ]
```

## 3: Tree Count Refinement

```{r refine2}
# Set the seed for reproducibility
set.seed(10312022)

# Define the grid of values for mtry, num.trees, and min.node.size
mtry_values <- 16
num_trees <- seq(570, 670, 10)
min_node_size_values <- 11

num_combinations <- length(mtry_values) * length(num_trees) * length(min_node_size_values)
results_matrix2 <- matrix(NA, nrow = num_combinations, ncol = 4,
                         dimnames = list(NULL, c("mtry", "num.trees", "min.node.size", "Accuracy")))

index <- 1

for (i in seq_along(mtry_values)) {
 for (j in seq_along(num_trees)) {
  for (k in seq_along(min_node_size_values)) {
   grid <- expand.grid(
    mtry = mtry_values[i],
    splitrule = 'gini',
    min.node.size = min_node_size_values[k]
   )
   
   rforest <- train(blueprint,
                    data = dat,
                    method = 'ranger',
                    trControl = cv,
                    tuneGrid = grid,
                    num.trees = num_trees[j],
                    replace = TRUE,
                    sample.fraction = 0.8,
                    max.depth = 9,
                    importance = 'permutation'
   )
   
   results_matrix2[index, 1] <- mtry_values[i]
   results_matrix2[index, 2] <- num_trees[j]
   results_matrix2[index, 3] <- min_node_size_values[k]
   results_matrix2[index, 4] <- rforest$results$Accuracy
   
   index <- index + 1
  }
 }
}

# Find the row index with the highest accuracy
max_Accuracy_row3 <- which.max(results_matrix2[, "Accuracy"])

# Get the values (mtry, num.trees, min.node.size, accuracy) for the row with the highest accuracy
best_model_values3 <- results_matrix2[max_Accuracy_row3, ]
```

## 4: Final Model

```{r bestfit}
# Set seed for reproducibility
set.seed(10312022)

# Define the parameter grid
grid <- expand.grid(
  mtry = 16,
  min.node.size = 11,
  splitrule = 'gini'
)

# Train the final model with optimal parameters
rforest <- caret::train(
  blueprint,
  data = dat,
  method = 'ranger',
  trControl = cv,
  tuneGrid = grid,
  num.trees = 650,
  replace = TRUE,
  sample.fraction = 0.8,
  max.depth = 9,
  importance = 'permutation',
  scale.permutation.importance = T)

perm <- as.data.frame(rforest[["finalModel"]][["variable.importance"]])

perm$variable <- rownames(perm)
rownames(perm) <- NULL

# Obtain predictions
obs <- rforest$pred$obs
pred <- rforest$pred$pred

# Create confusion matrix
conf_matrix <- confusionMatrix(data = factor(pred), reference = factor(obs), positive = "Yes")

# Extract the confusion matrix
cm <- conf_matrix$table

# Calculate True Positives (TP), True Negatives (TN), False Positives (FP)
TN <- cm["No",  "No"]
FN <- cm["No",  "Yes"]
FP <- cm["Yes", "No"]
TP <- cm["Yes", "Yes"]

# Calculate Accuracy
rforest_ACC <- (TP + TN) / sum(cm)

# Calculate Precision
rforest_PRE <- TP / (TP + FP)

# Calculate False Positive Rate (FPR)
rforest_FPR <- FP / (FP + TN)

# Calculate True Negative Rate (TNR)
rforest_TNR <- TN / (TN + FP)

# Calculate True Positive Rate (TPR)
rforest_TPR <- TP / (TP + FN)

# Calculate AUC
cut.obj <- cutpointr(x = rforest$pred$Yes,
                     class = rforest$pred$obs)
rforest_AUC = cutpointr::auc(cut.obj)
```


# Final Model Cross-Validation Performance

```{r xfold}
predictions <- rforest[["pred"]]

# Initialize an empty matrix to store results
xv_results <- matrix(NA, nrow = 10, ncol = 7,
                  dimnames = list(NULL, c("Fold", "AUC", "ACC", "PRE", "FPR", "TNR", "TPR")))

# Loop through each fold
for (i in 1:10) {
 # Subset the predictions dataframe for the current fold
 fold <- subset(predictions, Resample == paste0("Resample", sprintf("%02d", i)))
 
 # Create confusion matrix
 conf_matrix <- confusionMatrix(data = factor(fold$pred), reference = factor(fold$obs), positive = "Yes")
 
 # Extract the confusion matrix
 cm <- conf_matrix$table
 
 # Calculate True Positives (TP), True Negatives (TN), False Positives (FP)
 TN <- cm["No",  "No"]
 FN <- cm["No",  "Yes"]
 FP <- cm["Yes", "No"]
 TP <- cm["Yes", "Yes"]
 
 # Calculate Accuracy
 ACC <- (TP + TN) / sum(cm)
 
 # Calculate Precision
 PRE <- TP / (TP + FP)
 
 # Calculate False Positive Rate (FPR)
 FPR <- FP / (FP + TN)
 
 # Calculate True Negative Rate (TNR)
 TNR <- TN / (TN + FP)
 
 # Calculate True Positive Rate (TPR)
 TPR <- TP / (TP + FN)
 
 # Calculate AUC using cutpointr
 cut.obj <- cutpointr(x = fold$Yes, class = fold$obs)
 AUC <- auc(cut.obj)
 
 # Store results in the matrix
 xv_results[i, ] <- c(i, AUC, ACC, PRE, FPR, TNR, TPR)
}

# Print the results matrix
xv_results <- as.data.frame(xv_results)

# Calculate mean and standard deviation and round to the second decimal point
mean_values <- sapply(xv_results[, -1], function(x) round(mean(x), 2))
sd_values <- sapply(xv_results[, -1], function(x) round(sd(x), 2))

# Print means and standard deviations
cat("Mean:\n")
print(mean_values)
cat("\nStandard Deviation:\n")
print(sd_values)
```

# Baked Data and DALEX Explainer

Depending on Ranger version, you may encounter difficulty when generating DALEX Explainer object. This worked for us under V 0.16 and 0.17.

```{r Explainer}
fitted_rf_model <- rforest$finalModel #pull ranger model from rforest list

prepped_recipe <- prep(blueprint, training = dat)
baked <- bake(prepped_recipe, new_data = dat) #match dataframe to recipe

target <- as.numeric(baked$drugdx) - 1 #outcome must be numeric (not factor)

explainer_rf <- DALEX::explain(fitted_rf_model, data = baked[,3:55],
                        y = target) #create DALEX explainer object

# pred_fun <- function(model, newdata) {
#   out <- predict(model, data = newdata, type = "response")$predictions
#   # extract "Yes" probability
#   return(out[, "Yes"])
# }
# 
# explainer_rf <- DALEX::explain(
#   model = fitted_rf_model,
#   data = baked[, 3:55],
#   y = target,  # numeric 0/1
#   predict_function = pred_fun,
#   label = "ranger_prob_rf"
# )

```


# Descriptive Stats & Unadjusted Comparisons

```{r}
# Total Sample
baked %>% 
 select(-deid) %>% 
 tbl_summary(
    type = list(grades_rev ~ "continuous",
                legalsev ~ "continuous",
                pviclevel ~ "continuous",
                pagglevel ~ "continuous",
                crime ~ "continuous",
                sedare1 ~ "continuous",
                sedare2 ~ "continuous",
                sedare3 ~ "continuous",
                sedare4 ~ "continuous",
                sedare5 ~ "continuous",
                sedare6 ~ "continuous",
                sedare7 ~ "continuous",
                sedare8 ~ "continuous"),
    statistic = list(
      all_continuous() ~ "{mean} ({sd}) {min} - {max}",
      all_categorical() ~ "{n} / {N} ({p}%)"),
    digits = list(all_categorical() ~ 1,
     all_continuous() ~ 2))

# By Group and Unadjusted Comparisons

# p_format <- function(x) {
#   ifelse(x < 0.01, "**", ifelse(x < 0.05, "*", ""))
# }

baked %>%
  select(-deid) %>%
  tbl_summary(
    by = drugdx,
    type = list(
      grades_rev ~ "continuous",
      legalsev ~ "continuous",
      pviclevel ~ "continuous",
      pagglevel ~ "continuous",
      crime ~ "continuous",
      sedare1 ~ "continuous",
      sedare2 ~ "continuous",
      sedare3 ~ "continuous",
      sedare4 ~ "continuous",
      sedare5 ~ "continuous",
      sedare6 ~ "continuous",
      sedare7 ~ "continuous",
      sedare8 ~ "continuous"
    ),
    statistic = list(
      all_continuous() ~ "{mean} ({sd})",
      all_categorical() ~ "{n} / {N} ({p}%)"
    ),
    digits = list(
      all_categorical() ~ 1,
      all_continuous() ~ 2
    ),
    missing_text = "(Missing)"
  ) %>%
    add_p(
    test = list(
      all_continuous() ~ "t.test"
    ),
    pvalue_fun = ~ style_pvalue(.x, digits = 3)
  ) %>%
  # modify_table_styling(
  #   columns = "p.value",
  #   rows = !is.na(p.value),  # Apply to all rows where p.value is not NA
  #   fmt_fun = p_format
  # ) %>%
  bold_p()

# Loops for Effect Sizes

# Function to calculate odds ratio for a categorical variable
calculate_odds_ratio <- function(data, var, group_var) {
  contingency_table <- table(data[[var]], data[[group_var]])
  odds_ratio <- oddsratio(contingency_table)$measure
  return(odds_ratio)
}

# Function to calculate Cohen's d for a continuous variable
calculate_cohens_d <- function(data, var, group_var) {
  groups <- split(data[[var]], data[[group_var]])
  cohen_d <- cohen.d(groups[[1]], groups[[2]])
  return(cohen_d)
}

# List of categorical and continuous variables
categorical_vars <- c(
  "demosex", "livewith", "school", "gang1", "weapon1", 
  "weapon2a", "sexint", "publicass", "partnervic", "pcts", "binge", 
  "vgroup", "alcdx", "ptsd", "cdapd", "sexdrug", "mentman", "mentwoman", 
  "demoage_Age.14.to.17", "demoage_Age.18.to.20", "demoage_Age.21.to.24", 
  "demorac_AA.or.Black", "demorac_White", "demorac_Multiple.Races", 
  "demorac_American.Indian.Asian.Native.Hawaiian"
)

continuous_vars <- c(
  "fight", "grades_rev", "reatt_rev", "pviclevel", "pagglevel", "agedruginit", 
  "legalsev", "dui", "infrndps", "infrndng", "parntsup", "prntdral", 
  "famanger", "nofight", "commviol", "bsi", "anx", "nprcts1to13", 
  "npects1to13", "crime", "sedare1", "sedare2", "sedare3", "sedare4",
  "sedare5", "sedare6", "sedare7", "sedare8"
)


# Initialize lists to store results
odds_ratios <- list()
cohens_d <- list()

# Calculate odds ratios for categorical variables
for (var in categorical_vars) {
  odds_ratios[[var]] <- calculate_odds_ratio(baked, var, "drugdx")
}

# Calculate Cohen's d for continuous variables
for (var in continuous_vars) {
  cohens_d[[var]] <- calculate_cohens_d(baked, var, "drugdx")
}

# Display results
print("Odds Ratios for Categorical Variables:")
print(odds_ratios)
print("Cohen's d for Continuous Variables:")
print(cohens_d)
```


# Global Assessments

## Variable Importance

```{r permutation}
varimp <- perm %>%
 mutate(permimp = `rforest[["finalModel"]][["variable.importance"]]`) %>% 
 dplyr::select(-`rforest[["finalModel"]][["variable.importance"]]`) %>% 
 arrange(desc(permimp)) %>% 
 dplyr::select(variable, permimp)

# Define your custom colors
drwhycolors <- c("Risk Factor" = "#371ea3", 
                   "Protective Factor" = "#8bdcbe", 
                   "Demographic/Personal Characteristic" = "#f05a71")


impplot <- varimp %>% 
 mutate(labels = c("Intoxicated Driving", "Negative Peer Influence",
                   "Alcohol Use Disorder", "Tempted - Let Myself Down", 
                   "Conduct Disorder or ASPD", "Drug Initiation Age",
                   "Crime", "Tempted - Family Problems",
                   "Biological Sex", "Academic Performance",
                   
                   "Tempted - Friend Problems", "Anxiety",
                   "Non-Partner Violence Perpetration", "Legal Severity",
                   "Tempted - All Friends Were Doing It", "Gang Affiliation",
                   "Fight Avoidance", "Intoxicated Sex",
                   "Community Violence", "Depression",
                   
                   "Positive Peer Influence", "Parent Support", 
                   "Family Anger", "Tempted - People Didn't Like Me",  
                   "Tempted - Worried About a Problem", "Aged 14-17", 
                   "Tempted - Friends Would Like Me More", "Tempted - Made Fun of For Abstaining",
                   "Retaliation Attitudes", "Fighting Behavior",
                   
                   "Knife/Razor Carrying", "Aged 18-20",
                   "IPV Victimization Severity", "IPV Perpetration Severity",
                   "IPV", "Non-Partner Violence Victimization",
                   "Binge Drinking", "White Race",
                   "Parent Substance Use", "Living With Parents",
                   
                   "Firearm Carrying", "Study Group",
                   "Black Race", "IPV Victimization",
                   "Male Mentorship", "Posttraumatic Stress Disorder",
                   "Attending School", "Sexual Intercourse",
                   "Other Race", "Multiple Races", 
                   
                   "Female Mentorship", "Public Assistance", 
                   "Aged 21-24"),
        
        category = c("Risk Factor", "Risk Factor",
                   "Risk Factor", "Risk Factor", 
                   "Risk Factor", "Protective Factor",
                   "Risk Factor", "Risk Factor",
                   "Demographic/Personal Characteristic", "Protective Factor",
                   
                   "Risk Factor", "Risk Factor",
                   "Risk Factor", "Risk Factor",
                   "Risk Factor", "Risk Factor",
                   "Protective Factor", "Risk Factor",
                   "Risk Factor", "Risk Factor",
                   
                   "Protective Factor", "Protective Factor", 
                   "Risk Factor", "Risk Factor",  
                   "Risk Factor", "Demographic/Personal Characteristic", 
                   "Risk Factor", "Risk Factor",
                   "Risk Factor", "Risk Factor",
                   
                   "Risk Factor", "Demographic/Personal Characteristic",
                   "Risk Factor", "Risk Factor",
                   "Risk Factor", "Risk Factor",
                   "Risk Factor", "Demographic/Personal Characteristic",
                   "Risk Factor", "Demographic/Personal Characteristic",
                   "Risk Factor", "Demographic/Personal Characteristic",
                   "Demographic/Personal Characteristic", "Risk Factor",
                   "Protective Factor", "Risk Factor",
                   "Demographic/Personal Characteristic", "Demographic/Personal Characteristic",
                   "Demographic/Personal Characteristic", "Demographic/Personal Characteristic", 
                   
                   "Protective Factor", "Demographic/Personal Characteristic", 
                   "Demographic/Personal Characteristic")) %>% 
 ggplot(aes(x = permimp, y = reorder(labels, permimp), group = category, color = category)) +
 geom_vline(xintercept = 0, colour="gray30", linetype = "solid") +
 geom_segment(aes(yend = labels), xend = 0, colour = "black") +
 geom_point(size = 3.5) + 
 labs(x = "Scaled Permutation Importance", y = "", title = "") +
 scale_x_continuous(limits = c(-4, 25), expand = c(0, 0)) +
 scale_color_manual(values = drwhycolors) +
 theme_bw() +
 theme(axis.text.x = element_text(size = 11),
       axis.text.y = element_text(size = 11),
       axis.title.x = element_text(size = 12),
       legend.position = "bottom",
       legend.title = element_blank(),
       legend.text = element_text(size = 10))
```

## Accumulated Local Effects (ALE)

### Model Profiles

```{r}
# Continuous
mp_cont <- model_profile(explainer = explainer_rf, type = "conditional", N = NULL,
                     variables = c("dui", "infrndng", 
                                   "sedare1", "agedruginit", 
                                   "crime", "sedare4", 
                                   "grades_rev", "sedare3",
                                   "anx"))

ale_cont <- mp_cont[["agr_profiles"]] #pull ALEs from profile

plot(ale_cont)

# Categorical
mp_cat <- model_profile(explainer = explainer_rf, type = "conditional", N = NULL,
                     variable_type = "categorical", 
                     variables = c("alcdx", "cdapd", "demosex"))

ale_cat <- mp_cat[["agr_profiles"]] #pull ALEs from profile

plot(ale_cat)
```

### Labels for Figures

```{r}
# Labels
contvars <- data.frame(variables = c("dui", "infrndng", "agedruginit", "crime",
                                     "bsi", "legalsev", "npects1to13", "infrndps",
                                     "famanger", "nofight", "parntsup", "sedare1", 
                                     "sedare2", "sedare3", "sedare4", "sedare5",
                                     "sedare6", "sedare7", "sedare8", "anx", "grades_rev"),
                          labels = c("Intoxicated Driving",
                                     "Negative Peer Influence", "Drug Initiation Age",
                                     "Crime", "Depression",
                                     "Legal Severity", "Non-Partner Violence Perpetration",
                                     "Positive Peer Influence", "Family Anger", "Fight Avoidance",
                                     "Parent Support", "Tempted - Let Myself Down", 
                                     "Tempted - People Didn't Like Me", 
                                     "Tempted - Friend Problems",
                                     "Tempted - Family Problems", 
                                     "Tempted - Made Fun of For Abstaining",
                                     "Tempted - Friends Would Like Me More", 
                                     "Tempted - All Friends Were Doing It", 
                                     "Tempted - Worried About a Problem", "Anxiety",
                                     "Academic Performance"))

labels_lookup <- contvars %>% 
 mutate(`_vname_` = variables) %>% 
 relocate(`_vname_`) %>% 
 select(-variables)

catvars <- data.frame(variables = c("alcdx", "cdapd", "demosex"),
                          labels = c("Alcohol Use Disorder", "Conduct Disorder or ASPD",
                                     "Biological Sex"))

labels_lookup2 <- catvars %>% 
 mutate(`_vname_` = variables) %>% 
 relocate(`_vname_`) %>% 
 select(-variables)
```

### Continuous Variable ALE Figures

```{r}
# Create an empty list to store the plots
plot_list <- list()

# Get unique values of _vname_
unique_vnames <- unique(ale_cont$`_vname_`)

# Loop through each unique vname and create plots
for (vname in unique_vnames) {
  subset_data <- subset(ale_cont, `_vname_` == vname)
  
  # Get the corresponding label from the lookup table
  label <- labels_lookup$label[labels_lookup$`_vname_` == vname]
  
  # Calculate the mean value of the corresponding variable in the baked dataframe
  mean_value <- mean(baked[[vname]], na.rm = TRUE)
  
  p <- ggplot(data = subset_data, aes(x = `_x_`, y = `_yhat_`)) +
    geom_vline(xintercept = mean_value, linetype = "dashed", color = "black") +
    geom_line(color = "#371ea3", linewidth = 1.5) +
    geom_rug(data = baked, aes(x = .data[[vname]]), sides="b", alpha = .15, linewidth = 1.25, 
             inherit.aes = FALSE, length = unit(0.15,"cm")) +
    labs(x = label, y = "") +
    scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +
    theme_bw() +
    theme(legend.position = "none",
          axis.text.x = element_text(size = 11),
          axis.text.y = element_text(size = 11),
          axis.title.x = element_text(size = 12))
  
  # Save the plot in the list with a unique name
  plot_list[[vname]] <- p
  
  # Optionally display the plot
  print(p)
}
```

### Categorical Variable ALE Figures

```{r}
# Create an empty list to store the plots
plot_list2 <- list()

# Get unique values of _vname_
unique_vnames2 <- unique(ale_cat$`_vname_`)

# Loop through each unique vname and create plots
for (vname in unique_vnames2) {
  subset_data <- subset(ale_cat, `_vname_` == vname)
  
  # Get the corresponding label from the lookup table
  label <- labels_lookup2$label[labels_lookup2$`_vname_` == vname]
  
  p2 <- ggplot(data = subset_data, aes(x = `_x_`, y = `_yhat_`)) +
    geom_col(color = "black",fill = "#371ea3", width = .5, size = .75) +
    labs(x = label, y = "") +
    scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +
    theme_bw() +
    theme(legend.position = "none",
          axis.text.x = element_text(size = 11),
          axis.text.y = element_text(size = 11),
          axis.title.x = element_text(size = 12))
  
  # Save the plot in the list with a unique name
  plot_list2[[vname]] <- p2
  
  # Optionally display the plot
  print(p2)
}
```

### Arranging ALE Figures

```{r}
# Function to save ggplot objects from a list to the environment
save_ggplots_to_workspace <- function(plot_list, prefix = "ale") {
  for (plot_name in names(plot_list)) {
    assign(paste0(prefix, "_", plot_name), plot_list[[plot_name]], envir = .GlobalEnv)
  }
}

# Save plots from plot_list to the workspace
save_ggplots_to_workspace(plot_list)

# Save plots from plot_list2 to the workspace
save_ggplots_to_workspace(plot_list2)

ales <- ale_dui + ale_infrndng + 
 ale_alcdx + ale_sedare1 + 
 ale_cdapd + ale_agedruginit + 
 ale_crime + ale_demosex + 
 ale_grades_rev + ale_anx +
 ale_sedare3 + ale_sedare4 +
 plot_layout(nrow = 6, byrow = TRUE) +
 plot_annotation(tag_levels = 'A')

ales_wrapped <- wrap_elements(ales) +
  labs(tag = "Predicted Probability") +
  theme(plot.tag = element_text(size = rel(1.2), angle = 90),
  plot.tag.position = "left")
```


# Local Assessments

## Simultate Cases

We simulated cases by specifying certain variables (within range of sample) and imputing others with MICE. This was to keep within ICPSR boundary of only reporting aggregate data from study participants.

While we initially simulated two cases, we only included analyses of one case in the publication due to manuscript length limits.

```{r}
# Create a blank row with the same types as the original dataframe
blank_rows <- dat[1:2, ]  # Copy the first row to get the same structure
blank_rows[] <- NA # Set all values in the copied row to NA

# Add the blank row to the existing dataframe
datfaux <- rbind(dat, blank_rows)

# Fill target variable and some predictor variables
datfaux[601, "drugdx"] <- "No"
datfaux[602, "drugdx"] <- "No"
datfaux[601, "deid"] <- "S601"
datfaux[602, "deid"] <- "S602"
datfaux[601, "dui"] <- 0
datfaux[602, "dui"] <- 0
# datfaux[601, "fight"] <- .25
datfaux[601, "demosex"] <- "Female"
datfaux[602, "bsi"] <- 15
datfaux[602, "anx"] <- 8
datfaux[602, "infrndps"] <- 3.5
datfaux[601, "infrndps"] <- 2.25
datfaux[601, "agedruginit"] <- 17
datfaux[602, "agedruginit"] <- 16
datfaux[601, "crime"] <- 0
datfaux[601, "cdapd"] <- "No"
datfaux[602, "cdapd"] <- "No"
datfaux[601, "infrndng"] <- 2.14285714285714
datfaux[601, "famanger"] <- 2
datfaux[602, "infrndng"] <- 1.71428571428571
datfaux[602, "crime"] <- 0
datfaux[601, "npects1to13"] <- 7
datfaux[601, "nofight"] <- 2
datfaux[602, "alcdx"] <- "No"
datfaux[601, "alcdx"] <- "No"
datfaux[602, "legalsev"] <- 0
datfaux[601, "bsi"] <- 0
datfaux[601, "anx"] <- 0
datfaux[602, "legalsev"] <- 0
datfaux[602, "npects1to13"] <- 0
datfaux[601, "parntsup"] <- 3.16666666666667

datfaux[602, "sedare1"] <- 5
datfaux[602, "sedare8"] <- 5
datfaux[602, "sedare4"] <- 2
datfaux[602, "sedare6"] <- 1
datfaux[602, "sedare7"] <- 1

datfaux[601, "sedare1"] <- 1
datfaux[601, "sedare3"] <- 2
datfaux[601, "sedare6"] <- 5
datfaux[601, "sedare7"] <- 5
datfaux[601, "sedare8"] <- 1
datfaux[601, "sedare4"] <- 1

imp0 <- mice(datfaux, maxit = 0, 
    defaultMethod = c("norm", 'pmm', 'logreg', 'polr', 'polyreg'))
meth <- imp0[["method"]] #meth vector

# change methods for following variable
meth["demoage"] <- "polyreg"
meth["demorac"] <- "polyreg"
meth["livewith"] <- "logreg"
meth["school"] <- "logreg"
meth["gang1"] <- "logreg"
meth["weapon1"] <- "logreg"
meth["weapon2a"] <- "logreg"
meth["sexint"] <- "logreg"
meth["publicass"] <- "logreg"
meth["partnervic"] <- "logreg"
meth["pcts"] <- "logreg"
meth["vgroup"] <- "logreg"
meth["alcdx"] <- "logreg"
meth["ptsd"] <- "logreg"
meth["cdapd"] <- "logreg"
meth["sexdrug"] <- "logreg"
meth["mentman"] <- "logreg"
meth["mentwoman"] <- "logreg"
meth["binge"] <- "logreg"
meth["demosex"] <- "logreg"
meth["fight"] <- "pmm"
meth["grades_rev"] <- "pmm"
meth["reatt_rev"] <- "pmm"
meth["pviclevel"] <- "pmm"
meth["pagglevel"] <- "pmm"
meth["binge"] <- "pmm"
meth["agedruginit"] <- "pmm"
meth["legalsev"] <- "pmm"
meth["dui"] <- "pmm"
meth["nofight"] <- "pmm"
meth["bsi"] <- "pmm"
meth["anx"] <- "pmm"
meth["nprcts1to13"] <- "pmm"
meth["npects1to13"] <- "pmm"
meth["crime"] <- "pmm"
meth["commviol"] <- "pmm"
meth["sedare1"] <- "pmm"
meth["sedare2"] <- "pmm"
meth["sedare3"] <- "pmm"
meth["sedare4"] <- "pmm"
meth["sedare5"] <- "pmm"
meth["sedare6"] <- "pmm"
meth["sedare7"] <- "pmm"
meth["sedare8"] <- "pmm"
meth["parntsup"] <- "pmm"
meth["prntdral"] <- "pmm"
meth["infrndps"] <- "pmm"
meth["famanger"] <- "pmm"

predmatrix <- imp0$predictorMatrix #specify variables for models

# do not include IDs in regression imputation models.
predmatrix[, colnames(predmatrix) %in% c("deid")] <- 0
predmatrix["deid", ] <- 0

set.seed(10312022)
imp <- mice(datfaux, method = meth, predictorMatrix = predmatrix, m = 1, maxit = 20, 
       seed = 10312022)

imp_long <- complete(imp, action = 'long', include = FALSE)

imp_long_filtered <- imp_long %>% 
 select(-.imp, -.id) %>% 
 dplyr::filter(deid == "S601" | deid == "S602")

baked2 <- bake(prepped_recipe, new_data = imp_long_filtered) #bake to match recipe
```

## Variable Contributions

### Case Number 1

```{r}
breakdown_hc <- iBreakDown::local_attributions(explainer_rf, baked2[1,3:55])

plot(breakdown_hc, max_features = 8)
```

### Case Number 2

```{r}
breakdown_lc <- iBreakDown::local_attributions(explainer_rf, baked2[2,3:55])

plot(breakdown_lc, max_features = 8)
```

### Variable Contribution Figures

We adapted breakdown plot functions from  breakDown package (Staniak & Biecek) for figure preferences/aesthetics.

```{r}
source("bdplot_function.R")
source("select_only_k_features2.R")
source("prepare_data_for_break_down_plot2.R")

select_only_k_features <- getAnywhere(select_only_k_features)[3]
prepare_data_for_break_down_plot <- getAnywhere(prepare_data_for_break_down_plot)[2]

breakdown_hc$variable[1] <- "Intercept"
breakdown_hc$variable[2] <- "Drug Initiation Age = 17"
breakdown_hc$variable[3] <- "Negative Peer Influence = 2.14"
breakdown_hc$variable[4] <- "Intoxicated Driving = 0"
breakdown_hc$variable[5] <- "Non-Partner Violence Perpetration = 7"
breakdown_hc$variable[6] <- "Crime = 0"
breakdown_hc$variable[8] <- "Biological Sex = Female"
breakdown_hc$variable[11] <- "Alcohol Use Disorder = No"
breakdown_hc$variable[17] <- "Tempted - Made Fun of For Abstaining = 4"
breakdown_hc$variable[55] <- "Prediction"

breakdown_hc <- breakdown_hc %>% 
 mutate(label = "Simulated Case")

bdplot1 <- bdplot(breakdown_hc, max_features = 8) + scale_y_continuous(limits = c(.40, .65)) +
 labs(y = "Predicted Probability")

breakdown_lc$variable[1] <- "Intercept"
breakdown_lc$variable[2] <- "Tempted - Let Myself Down  = 5"
breakdown_lc$variable[3] <- "Positive Peer Influence = 3.5"
breakdown_lc$variable[4] <- "Intoxicated Driving = 0"
breakdown_lc$variable[5] <- "Community Violence = 1"
breakdown_lc$variable[6] <- "Depression = 15"
breakdown_lc$variable[8] <- "Crime = 0"
breakdown_lc$variable[13] <- "Conduct Disorder or ASPD = No"
breakdown_lc$variable[15] <- "Non-Partner Violence Perpetration = 0"
breakdown_lc$variable[55] <- "Prediction"

breakdown_lc <- breakdown_lc %>% 
 mutate(label = "Simulated Case #2")

bdplot2 <- bdplot(breakdown_lc, max_features = 8) + scale_y_continuous(limits = c(.40, .65)) +
 labs(y = "Predicted Probability")

breakdowns <- bdplot1 + bdplot2 +
 plot_layout(nrow = 2, byrow = TRUE) +
 plot_annotation(tag_levels = 'A')

bds_wrapped <- wrap_elements(breakdowns)
```

## Cetaris Paribis Profiles

### Case Number 1

```{r}
cp1_hc <- DALEX::predict_profile(explainer_rf, baked2[1,3:55], 
                                 variables = c("infrndng", "npects1to13"))

plot(cp1_hc, variables = c("infrndng", "npects1to13"))
```

### Cetaris Paribis Figures

```{r}
hc_only <- baked2[1,]

cp1_hc <- cp1_hc %>%
  rowwise() %>%
  mutate(x = get(`_vname_`))

# contvars <- data.frame(variables = c("dui", "sedare", "infrndng", "agedruginit", "crime", 
#                                         "sedarea", "bsi", "legalsev", "npects1to13", "infrndps", 
#                                         "famanger", "nofight", "anx", "parntsup", "commviol", "fight"),
#                           labels = c("Intoxicated Driving", "Drug Refusal Efficacy",
#                                      "Negative Peer Influence", "Drug Initiation Age",
#                                      "Crime", "Alcohol Refusal Efficacy", "Depression",
#                                      "Legal Severity", "Non-Partner Violence Perpetration",
#                                      "Positive Peer Influence", "Family Anger", "Fight Avoidance", 
#                                      "Anxiety", "Parent Support", "Community Violence",
#                                      "Fighting Behavior"))

labels_lookup <- contvars %>% 
 mutate(`_vname_` = variables) %>% 
 relocate(`_vname_`) %>% 
 select(-variables)

# Create an empty list to store the plots
plot_list3 <- list()

# Get unique values of _vname_
unique_vnames3 <- unique(cp1_hc$`_vname_`)

# Loop through each unique vname and create plots
for (vname in unique_vnames3) {
  subset_data <- subset(cp1_hc, `_vname_` == vname)
  
  # Get the corresponding label from the lookup table
  label <- labels_lookup$label[labels_lookup$`_vname_` == vname]
  
  # Get value of the case's corresponding variable
  value <- hc_only[[vname]]
  
  p <- ggplot(data = subset_data, aes(x = x, y = `_yhat_`)) +
    geom_line(color = "#371ea3", linewidth = 1.5) +
    geom_point(x = value, y = 0.4758262, shape = 23, size = 3, fill = "#8bdcbe", 
               color = "black") +
    labs(x = label, y = "") +
    scale_y_continuous(limits = c(.35, .55), expand = expansion(mult = c(0, 0.05))) +
    theme_bw() +
    theme(legend.position = "none",
          axis.text.x = element_text(size = 11),
          axis.text.y = element_text(size = 11),
          axis.title.x = element_text(size = 12))
  
  # Save the plot in the list with a unique name
  plot_list3[[vname]] <- p
  
  # Optionally display the plot
  print(p)
}
```

## Local Assessment Figure Arrangement

```{r}
cps <- plot_list3[["infrndng"]] + plot_list3[["npects1to13"]] +
 plot_layout(nrow = 1, byrow = TRUE) +
 plot_annotation(tag_levels = list(c('B1', 'B2')))

cps_wrapped <- wrap_elements(cps) +
  labs(tag = "Predicted Probability") +
  theme(plot.tag = element_text(size = rel(1.1), angle = 90),
  plot.tag.position = "left") + theme(plot.margin = unit(c(-1, 0, 0, 0), "null"),
    panel.spacing = unit(c(0, 0, 0, 0), "null"))

bdplot1_arrange <- bdplot1 +
 plot_layout(nrow = 1, byrow = TRUE) +
 plot_annotation(tag_levels = list(c('A')))

localplots <- bdplot1_arrange / free(cps_wrapped) +
 plot_layout(heights = c(1.75, 1.35))
```
